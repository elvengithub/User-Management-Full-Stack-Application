{"ast":null,"code":"import { BehaviorSubject, Subject } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { io } from 'socket.io-client';\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nexport let SocketService = /*#__PURE__*/(() => {\n  class SocketService {\n    constructor() {\n      this.socket = null;\n      this.onlineUsers = new BehaviorSubject([]);\n      this.registrationStats = new BehaviorSubject({\n        monthlyData: [],\n        totalRegistrations: 0\n      });\n      this.userStatusUpdates = new Subject();\n      // Socket status\n      this.isConnected = false;\n      this.currentUserId = '';\n      this.jwtToken = '';\n      this.reconnectAttempts = 0;\n      this.maxReconnectAttempts = 5;\n      this.reconnectDelay = 1000; // Start with 1 second\n      this.lastHeartbeat = null;\n      // Try to get the current user ID and token from localStorage\n      try {\n        const accountData = localStorage.getItem('account');\n        if (accountData) {\n          const account = JSON.parse(accountData);\n          this.currentUserId = account.id || '';\n          this.jwtToken = account.jwtToken || '';\n          // If we have credentials, try to connect\n          if (this.currentUserId && this.jwtToken) {\n            this.connect();\n          }\n        }\n      } catch (e) {\n        console.error('Error getting account from localStorage:', e);\n      }\n    }\n    // Set current user ID and token (call this after login)\n    setCurrentUser(userId, token) {\n      this.currentUserId = userId;\n      this.jwtToken = token;\n      // If connected, disconnect and reconnect with new token\n      if (this.isConnected) {\n        this.disconnect();\n      }\n      // Connect with new credentials\n      this.connect();\n    }\n    // Connect to the WebSocket server\n    connect() {\n      if (this.isConnected || !this.jwtToken) return;\n      console.log('Socket connecting...');\n      // Connect to the WebSocket server using the environment URL\n      const socketUrl = environment.wsUrl || environment.apiUrl.replace('/accounts', '');\n      console.log(`Connecting to WebSocket server at: ${socketUrl}`);\n      this.socket = io(socketUrl, {\n        auth: {\n          token: this.jwtToken\n        },\n        withCredentials: true,\n        transports: ['websocket', 'polling'],\n        autoConnect: false,\n        reconnection: true,\n        reconnectionAttempts: this.maxReconnectAttempts,\n        reconnectionDelay: this.reconnectDelay,\n        reconnectionDelayMax: 5000,\n        timeout: 10000\n      });\n      // Connect manually\n      this.socket.connect();\n      // Handle connection events\n      this.socket.on('connect', () => {\n        console.log('Socket connected successfully');\n        this.isConnected = true;\n        this.reconnectAttempts = 0;\n        this.reconnectDelay = 1000;\n        this.lastHeartbeat = new Date();\n        // Start sending heartbeats every 30 seconds\n        this.startHeartbeat();\n        // Request initial data\n        this.requestInitialData();\n      });\n      // Handle online users updates\n      this.socket.on('online-users-update', users => {\n        console.log('Received online users update:', users.length);\n        // Filter out users who haven't sent a heartbeat in the last 5 minutes\n        const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);\n        const activeUsers = users.filter(user => {\n          if (!user.lastActive) return false;\n          return new Date(user.lastActive) > fiveMinutesAgo;\n        });\n        this.onlineUsers.next(activeUsers);\n      });\n      // Handle user stats updates\n      this.socket.on('user-stats-update', stats => {\n        console.log('Received user stats update');\n        this.registrationStats.next(stats);\n      });\n      // Handle individual user status changes\n      this.socket.on('user-status-change', update => {\n        console.log('Received user status change:', update);\n        this.userStatusUpdates.next(update);\n        // Also update in the users array\n        const currentUsers = this.onlineUsers.value;\n        if (currentUsers.length > 0) {\n          const updatedUsers = currentUsers.map(user => {\n            if (user.id === update.userId) {\n              return Object.assign(Object.assign({}, user), {\n                isOnline: update.isOnline\n              });\n            }\n            return user;\n          });\n          this.onlineUsers.next(updatedUsers);\n        }\n      });\n      // Handle disconnect\n      this.socket.on('disconnect', () => {\n        console.log('Socket disconnected');\n        this.isConnected = false;\n        this.stopHeartbeat();\n        // Attempt to reconnect if we haven't exceeded max attempts\n        if (this.reconnectAttempts < this.maxReconnectAttempts) {\n          this.reconnectAttempts++;\n          this.reconnectDelay = Math.min(this.reconnectDelay * 2, 5000); // Exponential backoff\n          setTimeout(() => this.connect(), this.reconnectDelay);\n        }\n      });\n      // Handle connection errors\n      this.socket.on('connect_error', error => {\n        console.error('Socket connection error:', error);\n        this.isConnected = false;\n        // Attempt to reconnect if we haven't exceeded max attempts\n        if (this.reconnectAttempts < this.maxReconnectAttempts) {\n          this.reconnectAttempts++;\n          this.reconnectDelay = Math.min(this.reconnectDelay * 2, 5000); // Exponential backoff\n          setTimeout(() => this.connect(), this.reconnectDelay);\n        }\n      });\n    }\n    // Request initial data after connection\n    requestInitialData() {\n      if (this.socket && this.isConnected) {\n        this.socket.emit('get-online-users');\n        this.socket.emit('get-user-stats');\n      }\n    }\n    // Disconnect from the WebSocket server\n    disconnect() {\n      if (!this.isConnected || !this.socket) return;\n      console.log('Socket disconnecting...');\n      this.stopHeartbeat();\n      this.socket.disconnect();\n      this.socket = null;\n      this.isConnected = false;\n      this.reconnectAttempts = 0;\n      this.lastHeartbeat = null;\n    }\n    // Start sending heartbeats\n    startHeartbeat() {\n      this.stopHeartbeat(); // Clear any existing interval\n      this.heartbeatInterval = setInterval(() => {\n        if (this.socket && this.isConnected) {\n          this.socket.emit('heartbeat');\n          this.lastHeartbeat = new Date();\n        }\n      }, 30000); // Send heartbeat every 30 seconds\n    }\n    // Stop sending heartbeats\n    stopHeartbeat() {\n      if (this.heartbeatInterval) {\n        clearInterval(this.heartbeatInterval);\n        this.heartbeatInterval = null;\n      }\n    }\n    // Update online users from backend\n    updateOnlineUsers(users) {\n      // Make sure current user is always shown as online if logged in\n      if (this.currentUserId) {\n        users = users.map(user => {\n          if (user.id === this.currentUserId) {\n            return Object.assign(Object.assign({}, user), {\n              isOnline: true,\n              lastActive: new Date()\n            });\n          }\n          return user;\n        });\n      }\n      this.onlineUsers.next(users);\n    }\n    // Update registration stats\n    updateRegistrationStats(stats) {\n      this.registrationStats.next(stats);\n    }\n    // Get online users as observable\n    getOnlineUsers() {\n      // Request online users update if connected\n      if (this.socket && this.isConnected) {\n        this.socket.emit('get-online-users');\n      }\n      return this.onlineUsers.asObservable();\n    }\n    // Get registration stats as observable\n    getRegistrationStats() {\n      // Request stats update if connected\n      if (this.socket && this.isConnected) {\n        this.socket.emit('get-user-stats');\n      }\n      return this.registrationStats.asObservable();\n    }\n    // Get single user status changes\n    getUserStatusUpdates() {\n      return this.userStatusUpdates.asObservable();\n    }\n    // Helper method to get current online count\n    getOnlineCount() {\n      return this.onlineUsers.pipe(map(users => {\n        const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);\n        return users.filter(u => u.isOnline && u.lastActive && new Date(u.lastActive) > fiveMinutesAgo).length;\n      }));\n    }\n    // Helper method to get current offline count\n    getOfflineCount() {\n      return this.onlineUsers.pipe(map(users => {\n        const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);\n        return users.filter(u => !u.isOnline || !u.lastActive || new Date(u.lastActive) <= fiveMinutesAgo).length;\n      }));\n    }\n  }\n  SocketService.ɵfac = function SocketService_Factory(t) {\n    return new (t || SocketService)();\n  };\n  SocketService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: SocketService,\n    factory: SocketService.ɵfac,\n    providedIn: 'root'\n  });\n  return SocketService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}